# temp.groを読み込み
import ase.io

class make_cpmdinput():
     # pseudo potentialの辞書を作成．
     # * hard code :: いずれは擬ポテンシャルも指定できると良い．
     pseudo = {}
     pseudo["O"]="O_SG_BLYP"
     pseudo["H"]="H_SG_BLYP"
     pseudo["C"]="C_SG_BLYP"
     
     def __init__(self, ase_atoms):
         # get supercell size
         # * hard code : simple cubic only !!
         self.cell_parameter=ase_atoms.get_cell()[0][0] # 00の対角成分をとる．
         self.ase_atoms=ase_atoms

         self.lines_georelax='''
&INFO
   input generated by dieltools
   Bulk .
   --------
   Functional : GGA (?)
&END
         
&CPMD
   OPTIMIZE GEOMETRY XYZ
   FILEPATH
         ./tmp         
   CONVERGENCE GEOMETRY
         1.0e-2
   CONVERGENCE ORBITALS
         1.0e-7
   PRINT FORCES ON
   MAXSTEP
         10000
   VDW CORRECTION ON
&END
         
&SYSTEM
   !! type of symmetry
   !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {0:.10f} 1.0 1.0  0.0  0.0  0.0
   CUTOFF
         100.0
&END
         
&DFT
   FUNCTIONAL BLYP
&END
         
&VDW
   EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
   END EMPIRICAL CORRECTION
&END
         
&ATOMS
   '''.format(self.cell_parameter)

         self.lines_bomd_relax='''
 &INFO
  input generated by dieltools :: bomd relax calculation(3ps)
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  RESTART WAVEFUNCTION COORDINATES LATEST
        
  TRAJECTORY XYZ FORCES
     
  FILEPATH
   ./tmp
         
  TEMPERATURE
   300.0D0
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   3000
  TIMESTEP
   40.0
  PRINT FORCES ON
  RATTLE
   100 1e-6
  VDW CORRECTION ON
      
  &END
         
         &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
         SYMMETRY
         1
         ANGSTROM
         CELL
         {0:.10f} 1.0 1.0  0.0  0.0  0.0

         CUTOFF
         100.0
         &END
         
         &DFT
         FUNCTIONAL BLYP
         &END
         
         &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
         &END

         &ATOMS
         '''.format(self.cell_parameter)


         # CPMDでは，原子種類ごとに
         '''
         *pseudo/O_SG_BLYP KLEINMAN-BYLANDER
         LMAX=P
         32
         '''
         # みたいなのが必要．ということで，indexが入れ替わるごとに数が必要．
         
         # 連続する同じ原子種のリストを作成
         number_index= []
         pre_index=""
         counter=1
         for i,index in enumerate(self.ase_atoms.get_chemical_symbols()):
             if i == 0:
                 pre_index = index # pre_indexを代入しないとだめ． 
                 continue
             if i == len(self.ase_atoms.get_chemical_symbols())-1: #最後の原子種
                 counter = counter + 1
                 number_index.append(counter)
             if index == pre_index:
                 counter = counter+1
             elif index != pre_index:
                 number_index.append(counter) # 一つ前の原子種の数をappend
                 counter = 1 # リセット
             pre_index = index

         # わかりやすいようにnumber_indexの形を整える．
         new_index=[]
         for i in number_index:
             for j in range(i):
                 new_index.append(i)
         # print(new_index)
         self.new_index=new_index


     def make_georelax(self):
          # 
          filename_georelax="georelax.inp"

          f_georelax=open(filename_georelax,mode="w")
          f_georelax.write(self.lines_georelax)

          # 最終的な出力を作成．
          self.write_coordinates(f_georelax) # 座標を出力
          f_georelax.write("&END")
          f_georelax.close()
          return 0

     def make_bomd_relax(self):
          '''
          座標を引き継ぐrestartのNVT計算
          あくまで緩和用で，wannierの収集は行わない．
          '''

          # 
          filename_bomd="bomd-relax.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(self.lines_bomd_relax)
          self.write_coordinates(f_bomd) # 座標を出力
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     def make_bomd(self,max_step:float=10000,timestep:float=40):
          '''
          座標と波動関数を引き継いでNVTでwannierを計算する．
          '''
          
          lines_bomd_restart='''
 &INFO
  input generated by dieltools :: bomd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST
        
  TRAJECTORY XYZ FORCES
     
  FILEPATH
   ./tmp
         
  TEMPERATURE
   300.0D0
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   {0}
  TIMESTEP
   {1}
  PRINT FORCES ON
  RATTLE
   100 1e-6
  VDW CORRECTION ON
      
&END
         
&SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
    SYMMETRY
         1
    ANGSTROM
    CELL
         {2:.10f} 1.0 1.0  0.0  0.0  0.0

    CUTOFF
          100.0
&END
         
&DFT
     FUNCTIONAL BLYP
&END
         
&VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
&END

&ATOMS
         '''.format(max_step,timestep,self.cell_parameter)

          filename_bomd="bomd-restart.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_bomd_restart)
          self.write_coordinates(f_bomd) # 座標を出力
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     def make_bomd_restart(self,max_step:float=10000,timestep:float=40):
          '''
          座標，速度を引き継ぐrestartのNVT計算
          各ステップでwannierの収集も実行する．
          '''
          
          lines_bomd_wan_restart='''
 &INFO
  input generated by dieltools :: restart calculation :: bomd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS BO
  RESTART WAVEFUNCTION COORDINATES VELOCITIES LATEST
        
  TRAJECTORY XYZ FORCES
     
  FILEPATH
   ./tmp
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   {0}
  TIMESTEP
   {1}
  PRINT FORCES ON
  RATTLE
   100 1e-6
  VDW CORRECTION ON
      
  ! -------- WANNIER ---------
       
  DIPOLE DYNAMICS WANNIER SAMPLE
   1
      
  ! SD,JACOBI,SVD
   WANNIER OPTIMIZATION JACOBI
         
         ! W STEP, W EPS, W RAN, W MAXS
         WANNIER PARAMETER
         0.1 1e-7 0.0 2000
         &END
         
         &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
         SYMMETRY
         1
         ANGSTROM
         CELL
         {2:.10f} 1.0 1.0  0.0  0.0  0.0

         CUTOFF
         100.0
         &END
         
         &DFT
         FUNCTIONAL BLYP
         &END
         
         &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
         &END

         &ATOMS
         '''.format(max_step,timestep,self.cell_parameter)

          filename_bomd="bomd-wan-restart.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_bomd_wan_restart)
          self.write_coordinates(f_bomd) # 座標を出力
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     
     def make_cpmd(self,max_step:float=10000):
          '''
          bomdではなくcpmd用の計算．
          wannierの収集を行う．
          CP計算なのでtimestepは4.a.uで固定．
          '''

          lines_cpmd_wan='''
 &INFO
  input generated by dieltools :: cpmd+wf calculation
  Bulk .
  --------
  Functional : GGA (?)
 &END
 &CPMD
  MOLECULAR DYNAMICS CP
  RESTART WAVEFUNCTION COORDINATES LATEST
        
  TRAJECTORY XYZ FORCES
     
  FILEPATH
   ./tmp
         
  TEMPERATURE
   300.0D0
         
  BERENDSEN IONS
   300.0D0 10000
         
  MAXSTEP
   {0}
  TIMESTEP
   4.0
  PRINT FORCES ON
  RATTLE
   100 1e-6
  VDW CORRECTION ON
      
  ! -------- WANNIER ---------
       
  DIPOLE DYNAMICS WANNIER SAMPLE
   10
      
  ! SD,JACOBI,SVD
   WANNIER OPTIMIZATION JACOBI
         
  ! W STEP, W EPS, W RAN, W MAXS
   WANNIER PARAMETER
         0.1 1e-7 0.0 2000
   &END
         
   &SYSTEM
         !! type of symmetry
         !1 Simple CUBIC 2 FACE CENTERED CUBIC (FCC) 3 BODY CENTERED CUBIC (BCC) 4 HEXAGONAL 5 TRIGONAL or RHOMBOHEDRAL 6 TETRAGONAL 7 BODY CENTRED TETRAGONAL (BCT) 8 ORTHORHOMBIC 12 MONOCLINIC 14 TRICLINIC
   SYMMETRY
         1
   ANGSTROM
   CELL
         {1:.10f} 1.0 1.0  0.0  0.0  0.0

   CUTOFF
         100.0
   &END
         
   &DFT
         FUNCTIONAL BLYP
   &END
         
   &VDW
         EMPIRICAL CORRECTION
         VDW PARAMETERS
         ALL DFT-D2
         END EMPIRICAL CORRECTION
  &END

         &ATOMS
         '''.format(max_step,self.cell_parameter)


          filename_bomd="cpmd-wan.inp"

          f_bomd=open(filename_bomd,mode="w")
          f_bomd.write(lines_cpmd_wan)
          self.write_coordinates(f_bomd) # 座標を出力
          f_bomd.write("&END \n")
          f_bomd.close()
          return 0

     def write_coordinates(self,file):
          # 座標部分の出力を行う．
          ase_atoms_position=self.ase_atoms.get_positions()
          pre_index=""
          for i,index in enumerate(self.ase_atoms.get_chemical_symbols()):
               if index != pre_index:
                    file.write("\n")
                    file.write("*pseudo/{0} KLEINMAN-BYLANDER \n".format(self.pseudo[index]))
                    file.write("   LMAX=P \n")
                    file.write("   {0} \n".format(self.new_index[i]))
               file.write( " {0:.10f} {1:.10f} {2:.10f} \n".format(ase_atoms_position[i][0],ase_atoms_position[i][1],ase_atoms_position[i][2]))
               pre_index = index
          return 0
          


class make_cpmdinput_type2():
     '''
     type2では，原子種を並び替えると同時に，並び替えのindexを格納したファイルを返す．
     大きな系だと，type1の入力に対してTOO MANY ATOMIC SPECIES SPECIFIEDというエラーが出てくる場合がある．
     そのような場合にはtype2を用いる．
     TODO :: IONS+CENTERS.xyzに対する後処理コードも準備する予定．
     '''
     def __init__(self, ase_atoms,max_step:float=10000):     
          # temp.groを読み込み
          import ase.io

          tmp=ase_atoms.get_chemical_symbols()
          tmp2=ase_atoms.get_positions() # /12.9116  # 分極座標を取得する
          
          # get_cellを実行
          print(ase_atoms.get_cell())

          
          # まず，原子種と座標を持ったリストanswerを作成
          answer=[]
          for i in range(len(tmp)):
               answer.append([tmp[i], tmp2[i][0],tmp2[i][1],tmp2[i][2] ])
               
          # answerを原子種でソート
          answer2 = sorted(answer, key=lambda x:x[0])
               
          print(" ソート後の原子")
          print([i[0] for i in answer2])

          # 一方で，後で機械学習をするために配列のインデックスを取得して，逆変換を行えるようにする．
          # sortedでは，ソートするkeyが同じ値だった場合，他の最初の要素の順序を保つようにソートする（stableという性質らしい．https://docs.python.org/ja/3/howto/sorting.html 参照．）
          # そこで，answerの後ろにインデックス用の番号を降るようにする．
          import numpy as np
          
          # ソート用のリストを作成
          list=np.arange(len(answer))
          list_for_sort=[[i[0],i[1],i[2],i[3],j] for i,j in zip(answer,list)]
          
          sort_index=[i[4] for i in sorted(list_for_sort, key=lambda x:x[0])]
          print(" ソートした順番に関するインデックス")
          print(sort_index)
          np.savetxt("sort_index_1129.txt",np.array(sort_index))
