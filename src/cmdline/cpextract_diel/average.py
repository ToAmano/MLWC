import pandas as pd
import numpy as np
import argparse
import os
import datetime
import yaml
from pathlib import Path
import __version__
from include.mlwc_logger import root_logger
logger = root_logger(__name__)

class average_diel:
    def __init__(self,list_input_filename:list[str],window:int=1,max_freq_kayser:int=4000):
        self.list_input_filename = list_input_filename
        self.window = window
        self.max_freq_kayser = max_freq_kayser
    
    def read_file(self):
        list_df:list[pd.DataFrame] = []
        for input_filename in self.list_input_filename:
            logger.info(f"Reading {input_filename}")
            if not os.path.exists(input_filename):
                raise FileNotFoundError(f"{input_filename} not found")
            df_tmp = pd.read_csv(input_filename,comment="#")
            if "freq_kayser" not in df_tmp.columns:
                raise ValueError("freq_kayser is not in columns")
            for col in df_tmp.columns:
                if col.startswith("Unnamed:"):
                    df_tmp = df_tmp.drop(col,axis=1)
            df_tmp = df_tmp.set_index("freq_kayser")
            list_df.append(df_tmp)
        return list_df
        
    @classmethod
    def average_diel(cls,df:pd.DataFrame,window:int=1):
        df = df.copy()        
        # concat dataframes
        df = pd.concat(df) 
        # average over the same frequency
        df_mean = df.groupby(df.index).mean()
        # moving average
        window_func = np.ones(window)/window
        for col in df_mean.columns:
            if col == "freq_kayser":
                continue
            elif col == "freq_thz":
                continue
            else:
                df_mean[col] = np.convolve(df_mean[col], window_func, mode="same")
        df_mean = df_mean.reset_index()
        return df_mean
    
    @classmethod
    def truncate_diel(cls,df:pd.DataFrame,max_freq_kayser:int=4000):
        df = df.copy()
        df = df[df["freq_kayser"] <= max_freq_kayser]
        return df
    
    def save_file(self, df:pd.DataFrame)-> None:
        """
        処理結果をファイルCに保存するメソッド。結果をCSVファイルとして保存。
        """
        output_filename:str = self.list_input_filename[0]+f"_average_{self.window}.csv"
        if os.path.exists(output_filename):
            raise FileExistsError(f"{output_filename} already exists")
        # df.to_csv(self.output_file, index=False)
        with open(output_filename, 'a') as f:
            # 現在の日時を取得
            current_time = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            # コメント行を追加
            f.write(f'# File created on: {current_time}\n')
            f.write(f'# File generated by CPextract.py diel average version {__version__.__version__}.\n')
            f.write(f'# Parameters: window={self.window}, filename={self.list_input_filename}\n')
            f.write('# Data below:\n')
            df.to_csv(f,index=False)
        print(f"Results saved to {output_filename}")
        
        
    def execute(self):
        """
        一連の流れを実行するメソッド。ファイル読み込み、処理、保存を行う。
        """
        df:pd.DataFrame = self.read_file()
        df:pd.DataFrame = self.average_diel(df,self.window)
        df:pd.DataFrame = self.truncate_diel(df,self.max_freq_kayser)
        self.save_file(df)

def check_filename(list_filename:list[str]):
    list_filename_out:list[str] = []
    for filename in list_filename:
        filename = filename.strip("")     
        logger.info(f"Checking {filename}")
        if not os.path.exists(filename):
            raise FileNotFoundError(f"{filename} not found")
        list_filename_out.append(filename)
    return list_filename_out

def command_diel_average(args:argparse.Namespace):
    with open(args.Filename) as file:
        yml = yaml.safe_load(file)
        filelist = check_filename(yml["filename"])
    processor = average_diel(filelist, int(args.window), int(args.maxfreq))
    processor.execute()
    return 0