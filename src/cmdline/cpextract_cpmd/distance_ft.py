
import sys
import numpy as np
import pandas as pd
import ase
import ase.io 
import ase.units
import scipy
import argparse
import matplotlib.pyplot as plt
import cpmd.read_core
import cpmd.read_traj
import __version__
from include.file_io import to_csv_with_comment
from include.mlwc_logger import root_logger
logger = root_logger(__name__)

class distance_vector_autocorrelation:
    """ class to calculate distance auto-correlation function of given index i and j
        See 
    Returns:
        _type_: _description_
    """
    def __init__(self,filename:str,molfile:str, index:list[int], timestep:float,NUM_ATOM_PER_MOL:int,initial_step:int=1):
        self.__filename = filename # xyz
        self.__initial_step = initial_step # initial step to calculate msd
        self.__molfile = molfile # .mol
        self._index = index # index of atoms to calculate distance auto-correlation
        # timestep in [fs]
        self._timestep = timestep # timestep in [fs]
        self._NUM_ATOM_PER_MOL = NUM_ATOM_PER_MOL # including WCs & BCs
        
        import os
        if not os.path.isfile(self.__filename):
            raise FileNotFoundError(" ERROR :: "+str(self.__filename)+" does not exist !!")
        
        if self.__initial_step < 1:
            raise ValueError("ERROR: initial_step must be larger than 1")

        if not os.path.isfile(self.__molfile):
            raise FileNotFoundError(" ERROR :: "+str(self.__molfile)+" does not exist !!")
        
        
        # * itpデータの読み込み
        # note :: itpファイルは記述子からデータを読み込む場合は不要なのでコメントアウトしておく
        import ml.atomtype
        # 実際の読み込み
        if self.__molfile.endswith(".itp"):
            self.itp_data=ml.atomtype.read_itp(self.__molfile)
        elif self.__molfile.endswith(".mol"):
            self.itp_data=ml.atomtype.read_mol(self.__molfile)
        else:
            raise ValueError("ERROR :: itp_filename should end with .itp or .mol")
        # bonds_list=itp_data.bonds_list
        # NUM_MOL_ATOMS=self.itp_data.num_atoms_per_mol
        
        # read xyz
        logger.info(" READING TRAJECTORY... This may take a while, be patient.")
        self._traj = ase.io.read(self.__filename,index=":")
        logger.info(f" FINISH READING TRAJECTORY... :: len(traj) = {len(self._traj)}")
        # 
        self.NUM_MOL = len(self._traj[0])//self._NUM_ATOM_PER_MOL # number of molecules
        assert len(self._traj[0])%self._NUM_ATOM_PER_MOL == 0, "ERROR: Number of atoms in the first step is not divisible by the number of atoms per molecule"
        logger.info(f" NUM_MOL == {self.NUM_MOL}")

        self.comment:str = f'''
        # File generated by CPextract.py cpmd distanceft version {__version__.__version__}.\n
        # Parameters: filename={self.__filename}, molfilename={self.__molfile}\n
        # Parameters: index={self._index}\n
        # Parameters: initial_step={self.__initial_step}, timestep={self._timestep}\n
        # Data below:\n
        '''   
        
    def calc_distanceft(self):
        """calculate vdos

        Returns:
            _type_: _description_
        """
        import diel.hydrogenbond
        if len(self._index) != 2:
            raise ValueError("ERROR :: index should have two elements for distance calculation")
        # OHボンドのO原子のリスト
        atom1_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[0] for mol_id in range(self.NUM_MOL)]
        atom2_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[1] for mol_id in range(self.NUM_MOL)]
        # calculate atomic distances
        hydrogen_bond_list:np.ndarray = diel.hydrogenbond.calc_distance(self._traj,atom1_list,atom2_list)
        np.save(self.__filename+f"_atomindex_{self._index[0]}_{self._index[1]}_list.npy",hydrogen_bond_list)        
        # 全ての時系列に対して自己相関を計算 (axis=1で各行に対して自己相関を計算)
        # 'same' モードで時系列の長さを維持
        # !! numpy correlate does not support FFT
        correlations = np.apply_along_axis(lambda x: scipy.signal.correlate(x, x, mode='full'), axis=0, arr=hydrogen_bond_list)
        # 自己相関の平均化 (axis=1で全ての時系列に対する平均を取る)
        mean_correlation = np.mean(correlations, axis=1)[len(hydrogen_bond_list)-1:] # acf
        return mean_correlation
    
    def calc_vectorft(self):
        """calculate vdos

        Returns:
            _type_: _description_
        """
        import diel.hydrogenbond
        if len(self._index) != 2:
            raise ValueError("ERROR :: index should have two elements for vector calculation")
        # OHボンドのO原子のリスト
        atom1_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[0] for mol_id in range(self.NUM_MOL)]
        atom2_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[1] for mol_id in range(self.NUM_MOL)]
        # calculate OH vector
        bond_vectors:np.array = diel.hydrogenbond.calc_oh(self._traj,atom1_list,atom2_list)
        np.save(self.__filename+f"_angle_{self._index[0]}_{self._index[1]}_list.npy",bond_vectors)
        # 全ての時系列に対して自己相関を計算 (axis=1で各行に対して自己相関を計算)
        # 'same' モードで時系列の長さを維持
        # !! numpy correlate does not support FFT
        correlations = np.apply_along_axis(lambda x: scipy.signal.correlate(x, x, mode='full'), axis=0, arr=bond_vectors)
        correlations = np.sum(correlations,axis=2) # inner dot
        
        # 自己相関の平均化 (axis=1で全ての時系列に対する平均を取る)
        mean_correlation = np.mean(correlations, axis=1)[len(bond_vectors)-1:] # acf
        return mean_correlation
    

    def calc_angleft(self):
        """calculate vdos

        Returns:
            _type_: _description_
        """
        import diel.hydrogenbond
        if len(self._index) != 4:
            raise ValueError("ERROR :: index should have four elements for angle calculation")
        # OHボンドのO原子のリスト
        start_1_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[0] for mol_id in range(self.NUM_MOL)]
        end_1_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[1] for mol_id in range(self.NUM_MOL)]
        start_2_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[2] for mol_id in range(self.NUM_MOL)]
        end_2_list:list[int] =  [self._NUM_ATOM_PER_MOL*mol_id+self._index[3] for mol_id in range(self.NUM_MOL)]

        # calculate two (normalized) vectors
        bond_vectors_1:np.array = diel.hydrogenbond.calc_oh(self._traj,start_1_list,end_1_list)
        bond_vectors_2:np.array = diel.hydrogenbond.calc_oh(self._traj,start_2_list,end_2_list)
        bond_vector_angle:np.array = np.einsum("ijk,ijk -> ij", bond_vectors_1,bond_vectors_2)
        
        np.save(self.__filename+f"_angle_{self._index[0]}_{self._index[1]}_list.npy",bond_vector_angle)
        # 全ての時系列に対して自己相関を計算 (axis=1で各行に対して自己相関を計算)
        # 'same' モードで時系列の長さを維持
        # !! numpy correlate does not support FFT
        correlations = np.apply_along_axis(lambda x: scipy.signal.correlate(x, x, mode='full'), axis=0, arr=bond_vector_angle)
        
        # 自己相関の平均化 (axis=1で全ての時系列に対する平均を取る)
        mean_correlation = np.mean(correlations, axis=1)[len(bond_vector_angle)-1:] # acf
        return mean_correlation


    def save_files(self,mean_correlation:np.ndarray, strategy:str="distance"): 
        import diel.hydrogenbond  
        df_acf:pd.DataFrame = diel.hydrogenbond.make_df_acf(mean_correlation,self._timestep)
     
        to_csv_with_comment(df_acf,self.comment,self.__filename+f"_{strategy}_{self._index[0]}_{self._index[1]}_acf.csv")
        # df_acf.to_csv(self.__filename+"_roo_acf.csv",index=False)
        
        # Fourier Transform
        df_roo:pd.DataFrame = diel.hydrogenbond.calc_lengthcorr(mean_correlation, self._timestep)
        to_csv_with_comment(df_roo,self.comment,self.__filename+f"_{strategy}_{self._index[0]}_{self._index[1]}_ft.csv")
        # df_roo.to_csv(self.__filename+"_roo_ft.csv",index=False)
        return df_acf, df_roo

def command_cpmd_ft(args): # 二つの原子の距離相関
    roo = distance_vector_autocorrelation(args.filename,args.molfile, args.index, float(args.timestep),int(args.numatom),int(args.initial))
    if args.strategy == "distance":
        mean_correlation = roo.calc_distanceft()
    elif args.strategy == "vector":
        mean_correlation = roo.calc_vectorft()
    elif args.strategy == "angle":
        mean_correlation = roo.calc_angleft()
    else:
        raise ValueError("ERROR :: strategy should be either distance, vector or angle")
    roo.save_files(mean_correlation, args.strategy)
    return 0